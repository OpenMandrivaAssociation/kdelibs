From 265c5ba8927e32ff3d9d4042ca227922913bdcca Mon Sep 17 00:00:00 2001
From: Sergey Borovkov <serge.borovkov@gmail.com>
Date: Thu, 29 Nov 2012 12:24:02 +0400
Subject: [PATCH] Improve mimetype detection for webdav://

Don't use HEAD to get mimetype. Sometimes servers don't
return mimetype with it for webdav. It's also wrong for
directories - HEAD will return text/xml (since it's actually file
listing in XML)
---
 kioslave/http/http.cpp | 49 ++++++++++++++++++++++++++++++++++++-------------
 kioslave/http/http.h   |  8 +++++++-
 2 files changed, 43 insertions(+), 14 deletions(-)

diff --git a/kioslave/http/http.cpp b/kioslave/http/http.cpp
index b7f8e8d..35b0a10 100644
--- a/kioslave/http/http.cpp
+++ b/kioslave/http/http.cpp
@@ -736,7 +736,7 @@ void HTTPProtocol::listDir( const KUrl& url )
     return;
   resetSessionSettings();
 
-  davStatList( url, false );
+  davStatList( url, List );
 }
 
 void HTTPProtocol::davSetRequest( const QByteArray& requestXML )
@@ -745,7 +745,7 @@ void HTTPProtocol::davSetRequest( const QByteArray& requestXML )
   cachePostData(requestXML);
 }
 
-void HTTPProtocol::davStatList( const KUrl& url, bool stat )
+void HTTPProtocol::davStatList(const KUrl& url, WebDavRequest request )
 {
   UDSEntry entry;
 
@@ -797,8 +797,8 @@ void HTTPProtocol::davStatList( const KUrl& url, bool stat )
   m_request.method = query.isEmpty() ? DAV_PROPFIND : DAV_SEARCH;
   m_request.url.setQuery(QString());
   m_request.cacheTag.policy = CC_Reload;
-  m_request.davData.depth = stat ? 0 : 1;
-  if (!stat)
+  m_request.davData.depth = request ? 0 : 1;
+  if (request == List)
      m_request.url.adjustPath(KUrl::AddTrailingSlash);
 
   proceedUntilResponseContent( true );
@@ -846,7 +846,7 @@ void HTTPProtocol::davStatList( const KUrl& url, bool stat )
         QString name = thisURL.fileName();
 
         // base dir of a listDir(): name should be "."
-        if ( !stat && thisURL.path(KUrl::AddTrailingSlash).length() == url.path(KUrl::AddTrailingSlash).length() )
+        if ( request == List && thisURL.path(KUrl::AddTrailingSlash).length() == url.path(KUrl::AddTrailingSlash).length() )
           name = QLatin1Char('.');
 
         entry.insert( KIO::UDSEntry::UDS_NAME, name.isEmpty() ? href.text() : name );
@@ -859,17 +859,32 @@ void HTTPProtocol::davStatList( const KUrl& url, bool stat )
       // Since a lot of webdav servers seem not to send the content-type information
       // for the requested directory listings, we attempt to guess the mime-type from
       // the resource name so long as the resource is not a directory.
+      KMimeType::Ptr mime;
       if (entry.stringValue(KIO::UDSEntry::UDS_MIME_TYPE).isEmpty() &&
           entry.numberValue(KIO::UDSEntry::UDS_FILE_TYPE) != S_IFDIR) {
         int accuracy = 0;
-        KMimeType::Ptr mime = KMimeType::findByUrl(thisURL.fileName(), 0, false, true, &accuracy);
+        mime = KMimeType::findByUrl(thisURL.fileName(), 0, false, true, &accuracy);
         if (mime && !mime->isDefault() && accuracy == 100) {
           kDebug(7113) << "Setting" << mime->name() << "as guessed mime type for" << thisURL.fileName();
           entry.insert( KIO::UDSEntry::UDS_GUESSED_MIME_TYPE, mime->name());
         }
       }
 
-      if ( stat ) {
+      if ( request == Mimetype ) {
+        if (entry.numberValue( KIO::UDSEntry::UDS_FILE_TYPE ) == S_IFDIR)
+          m_mimeType = QLatin1String("httpd/directory");
+        else
+          m_mimeType = mime.isNull()
+              ? entry.stringValue( KIO::UDSEntry::UDS_MIME_TYPE )
+              : mime->name();
+        kDebug( 7113 ) << "Emit mimetype" << m_mimeType;
+
+        mimeType( m_mimeType );
+        davFinished();
+        return;
+      }
+
+      if ( request == Stat) {
         // return an item
         statEntry( entry );
         davFinished();
@@ -882,7 +897,7 @@ void HTTPProtocol::davStatList( const KUrl& url, bool stat )
     }
   }
 
-  if ( stat || !hasResponse ) {
+  if ( request != List || !hasResponse ) {
     error( ERR_DOES_NOT_EXIST, url.prettyUrl() );
     return;
   }
@@ -3209,6 +3224,7 @@ endParsing:
                 if (m_mimeType.endsWith(QLatin1Char('"'))) {
                     m_mimeType.chop(1);
                 }
+
                 kDebug(7113) << "Content-type:" << m_mimeType;
                 l.removeFirst();
             }
@@ -4023,12 +4039,19 @@ void HTTPProtocol::mimetype( const KUrl& url )
     return;
   resetSessionSettings();
 
-  m_request.method = HTTP_HEAD;
-  m_request.cacheTag.policy= CC_Cache;
+  if ( m_protocol != "webdav" && m_protocol != "webdavs" )  {
+    m_request.method = HTTP_HEAD;
+    m_request.cacheTag.policy= CC_Cache;
 
-  if (proceedUntilResponseHeader()) {
-    httpClose(m_request.isKeepAlive);
-    finished();
+    if (proceedUntilResponseHeader()) {
+      httpClose(m_request.isKeepAlive);
+      finished();
+    }
+  }
+  else {
+    m_request.method = DAV_PROPFIND;
+    m_request.cacheTag.policy= CC_Cache;
+    davStatList( url, Mimetype );
   }
 
   kDebug(7113) << m_mimeType;
diff --git a/kioslave/http/http.h b/kioslave/http/http.h
index 4d0b029..6572088 100644
--- a/kioslave/http/http.h
+++ b/kioslave/http/http.h
@@ -313,6 +313,12 @@ protected Q_SLOTS:
   void saveProxyAuthenticationForSocket();
 
 protected:
+  enum WebDavRequest {
+      List,
+      Stat,
+      Mimetype
+  };
+
   int readChunked();    ///< Read a chunk
   int readLimited();    ///< Read maximum m_iSize bytes.
   int readUnlimited();  ///< Read as much as possible.
@@ -395,7 +401,7 @@ protected:
    * Performs a WebDAV stat or list
    */
   void davSetRequest( const QByteArray& requestXML );
-  void davStatList( const KUrl& url, bool stat = true );
+  void davStatList(const KUrl& url, WebDavRequest request = Stat );
   void davParsePropstats( const QDomNodeList& propstats, KIO::UDSEntry& entry );
   void davParseActiveLocks( const QDomNodeList& activeLocks,
                             uint& lockCount );
-- 
1.7.11.3

